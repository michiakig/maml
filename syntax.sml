structure Syntax =
struct

structure T = TypeInf

datatype expr = Num of int
              | Bool of bool
              | Succ of expr
              | Pred of expr
              | IsZero of expr
              | If of expr * expr * expr
              | App of expr * expr
              | Fun of string * expr
              | Id of string

local
   val id = ref 0
in
   fun newId () = !id before id := !id + 1
   fun reset () = id := 0
end

(* keep track of lexically bound variables (in the obj lang)
 * assign Id nodes referring to the same bound var the same ast id *)
structure Env = BinaryMapFn(struct
   type ord_key = string
   val compare = String.compare
end)

exception FreeVariable

fun makeAst (env : int Env.map) : (expr -> T.ast) =
    fn e =>
       case e of
           (Num n) => T.Num (newId (), n)
         | (Bool b) => T.Bool (newId (), b)
         | (Succ e1) => T.Succ (newId (), makeAst env e1)
         | (Pred e1) => T.Pred (newId (), makeAst env e1)
         | (IsZero e1) => T.IsZero (newId (), makeAst env e1)
         | (If (e1, e2, e3)) => T.If (newId (), makeAst env e1, makeAst env e2, makeAst env e3)
         | (App (e1, e2)) => T.App (newId (), makeAst env e1, makeAst env e2)
         | (Fun (x, e1)) =>
           let
              (* id for bound var *)
              val id = newId ()
              (* recur on body expr, extending the env *)
              val e1' = makeAst (Env.insert (env, x, id)) e1
           in
              (* assign fun expr fresh id, plus id for bound var *)
              T.Fun (id, newId (), x, e1')
           end
         | (Id x) =>
           (* look up the bound var in the env,
            * use id generated by enclosing lexical fun expr *)
           case Env.find (env, x) of
               SOME id => T.Id (id, x)
             | NONE => raise FreeVariable

end
